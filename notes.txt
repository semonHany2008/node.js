                             javaScript
 - using + operator between two strings will concatenate the strings, but using other operators the strings will be implicitly converted into numbers including (NaN)
 - variables declared using let, var, const all are function block, while let and const only are scope block
 - variables are temporarily storing units, unlike the databases. as the variables store its values in RAM, while databases values stored into hard desk.
 - accessing element that is not exist in an array will print undefined.
 - previusly, in concatenation if the very first term was number the operation will be addition else it will be concat
   ,but now whatever the first term type it will be concatenation.
 - while accessing elements in list using bracket-notation we can't use negative indexes,
   ,but using methods like splice() we can use [-1, -2, -3, ...] to access elements from the end.
 - splice method role with list: Add, remove, or replace items in place. Extract part of an array.
 - reassigning a separate element from an array or string doesn't affect the original list, so we use splice() for replacing in list.
 - we use Object.assign(target, source) to take a value copy, because the direct assignment for object is a reference copy any change in the copied one will affect the original.
 - 'let i of list' iterate on the list elements but not with object
   ,while 'let i in list||object' iterate on keys.

                              Git
 - git is part of 'version control system' used to track changes made on file and enable accessing previous version.
 - its repo is local, unlike the github whose repo are global.
 * dealing with cmd(command line): 
   - 'cd' stands for change direction used to change the current path. it acts as a function with the new path as a parameter.
   - '.' refers to the current folder, while '..' refers to the previous folder in the relative path.
   - absolute path starts from the very first container (c:).
   - if the path contains spaces we put the whole path into double quotation.
   - the command 'dir' stands for directory used to show all available files in the current folder.
   - the command 'explorer.exe' open the current folder.
   - the command 'code .' open the current folder with VScode.
   - the command 'cursor .' open the current folder with cursor IDE.
   - 'mkdir folder_name' stands for 'make directory' used to create new folder.
   - the command 'git init' intialize an empty local repository.
   - 'git add .' add the files of the current folder to git. used when any changes are made.
   - 'git status' show if the current folder added to git or not.
   - there's an extension in VScode show the status of the file if ('U' untracked, 'A' added, 'M' modified, 'R' index renamed)
   - 'git commit -m "..."' used to send a message with any added changes to describe it.
   - 'git commit -am "..."' used to add changes and send a message with it in one command, but the file must be tracked and added already into git.
  - use powershell instead of cmd for more extensions and privileges.
  - 'git remote add origin ${repo path ended with .git}' enable using this github repo for later push.
  - 'git remote set-url origin ${repo path ended with .git}' to change the connection to another github repo.
  - 'git remote -v' show the current github repo related to the local git repo.
  - 'git branch -M main' used to make master branch(the default of git app) a main branch
  - 'git push -u origin main' used at the first time to push the git folder into github repository and later used to push any new changes.
  - 'git pull origin main --allow-unrelated-histories' used to merge the manual added file to github with ones added be git local repo.
  - 'git rm file_name' remove a file from git repo.
  - 'git mv -f file_name target_folder' move a file from the current folder(source) to the target.
    with the flag -f will overwrite the destination file if exist already.
  - https://download-directory.github.io/ this service enable downloading a specific folder from github repo.
  - git LFS (standing for large File Storage) used in this project for uploading zip folders or other large folders to github.
  - 'git lfs install' install git LFS.
  - 'git lfs track file-name' this command create gitattribute file containing the files git lfs tracks.
  - 'git checkout branch-name' this command check the status of commits between local and remote branch and warn the incoming changes that will result by the pul request.
  - 'git push origin semon-hany --force' this command push to the branch named semon-hany and overwrite the existing old branch without causing merge.

                              npm
- 'npm update' or 'npm upgrade' used to update installed libraries
- 'npm uninstall' delete installed library
- when we run the command 'npm i' without 'npm init' at first, it will initialize the project and create package.json, package-lock.json automatically.

                            node.js
- for exporting, importing from modules we use 'module.exports=property or method to be shared' in the source,
  'require(source file path)' in the target file then store the returned file content into variable.
-install the library readline to create an interface for taking input from user.
*status code:
  -401:unauthorized, 201: success and create, 403:forbidden, 404:page not found
- when the key will be the same as the variable_name including its value we just write the variable_name directly in the object according to the updated version of js (ES6).
- event loop: javaScript follow async approach in execution (single-threaded), but some functions like setTimeOut follow the webAPI service to be syncronous be waiting in an aside thread(libuv) until it's ready to execute and go to event queue, then to the call-stack.
- when the url error is in the endpoind the noFound page appear by the server
  , while when the error is in the domain the browser itself show the notFound page.
- we use the promise to make the code asyncronous according to the general logic async-await, which enable using .then((res)=>{}).catch((err)=>{})

                          client req
- headers: contains sensitive data like: authorization:'Bearer 3887', Content-Type:'application/json', accept:'application/json', accept-language:'ar-EG, en-US'.
- body: contains the data sent with post, put or patch requests.
- query: a string after ? contains the query parameters separated by &.
- params: Found after a ? in the URL. Usually written as key-value pairs separated by &.
- session: {}
- cookies: {}

                           express
- 'npm i nodemon express' this command install both nodemon and express libraries as a parameters (separated by space) to the function 'npm i'.
- when we run express server file we must use nodemon not the normal node keyword.
- when we send body to API request, we send it in the form of stringified json.
- using fs(file system) built-in module to readFileSync() or writeFileSync() to read and write data stored into an external json file, we must use JSON.parse() and JSON.stringify().
- we can't use err-parameter call-back function with fs.readFileSync(), it's used with fs.readFile() itself.
- we use app.all(/.*/,(req,res)=>{}) to handle not found end-points. using the regex /.*/ or the path "/{*any}/".
- when we separate the endpoints into another file than the express server we must run endPoint file which (in turn) require the server file.

                            ejs
- 'npm i ejs' stands for 'embedded javaScript' is a template engine used to enable writing js code into template html with the extension .ejs in views folder, and view engine enable reading views files while rendering by the express server
  , where set using:"app.set('view engine','ejs');" and "app.set('views', path.join(__dirname,'/views'))"
  , then we put html files into the views folder with the extension .ejs.
- js code into HTML template: each line put into <% %>tag
- sending variables from express server to ejs templates while rendering it: res.render('filename.ejs',{keys(variables):values})
  , then using the tag <%=variable to print%>  in HTML template.
- '__diename' in path library return the current folder absolute path.
- we access the folders inside public folder using / at the start of the path, in addition to using app.use(express.static(publicFolder_path)).
- when we write the path to a file or folder in the current folder we user ./ at the start of the path.
- .gitignore file used to ignore senesetive or large storage cost folders, write the file name directly '.env' and the folder with / at the front '/node_modules'.
- fetch method return a whole response from the server (containing server request statuses) so we wait to get the json object from (the response send by the endpoint) (data=await res.json()).

                            database                     
- username and email must be unique, in general.
- when creating new row in the mongo model we use 'new modelName({})' then 'addedRow_name.save()' or 'modelName.create({})'
- OTP (one-time password) is used for authentication in cases like forget_password its schema contains email and the generated otp_number.
- making a schema expired after a definite time: createdAt:{type:Date, default:Date.now, expires:300}.
- expires_value for the temporary schema by default in seconds, but can be '7d', '3h', '9m'.
- generating random number between (min, max)nums: Meth.floor(Math.random()*(max-min))+min.
- perplexing updating syntax:model_name.updateOne({filteration}, {$inc{numeric_property:increasing_amount}}) ... model_name.updateOne({filteration}, {$set:{property_1:new_value, property_2:new_value}})
- the method model_name.find().select('property_names separated by spaces') used to select the set properties only for the returned objects.
- the method model_name.find().limit(number of objects to select).
- the method model_name.find().skip(number of objects to skip).
- the method model_name.find().sort({property:1 or -1})used to sort the returned objects based on a specific property either descending(-1) or ascending(1).

                                advanced
- we install 'express-session' library to store the token inside the server session.
- we must save the jwt_secret_key and session_secret (string of chars, symbols and nums) in .env file for more security.
- we set this middleware to use for each endpoint: app.use(session({secret:process.env.session_secret, resave:false (prevent resave when no editing), saveUninitialized:flase (prevent save the guest users who don't signedin), cookie:{maxAge:1000*60*60, httpOnly:true (prevent sending requests with javascript scripts, but only using http), secure:false (in development mode to enable using http not strict with https)}})).
- the cookie in the browser is the same as the session of the server.
- res.cookie('token', token, {maxAge:1000*60, httpOnly:true, sameSite:'strict', secure:false}) after we install, require the library 'cookie-parser' and use it as middleware:app.use(cookieParser()), then we use req.cookies.{cookiename}to access it in protected endPoint.
- app.use(cors()) used to enable each server_ip to send request to the server.
- app.use(cors({origin:(origin, callback)=>{if(!origin || allowedOrigins.includes(origin)) callback(null, true); else: callback("this origin not allowed by cors!")}, credentials:true}));
- firefox browser and postman used the same ip of the localhost (127.0.0.1) then when they used for sending requests to localhost the origin ip will be undefined, so we handled it in the callback condition using(!origin).
- the callback function of the origin arrow function of the cors() middleware parameters are: (error, origin) in order.
- we can use live server for running from another ip server(front-end) as it run on a differet port (5500) than the local express server.
- when we used jwt.verify() there's a probability of an error occured so we use error-parameter_callback-fuction as a last parameter to handle it
  , but it's used in middlewares where there isn't a code after it require the decoded variable, although we use try-catch logic to handle this case.
- we install the library (nodemailer) for sending messages to an email.
- create the transporter function into file inside utils folder :const transporter=nodemailer.createTransport({service:'gmail', auth:{user:(email), pass:(app_password on google)}});
- const sendmail=(to, subject, text)=>{const mailOptions={from:process.env.EMAIL, to:to, subject:subject, text:text}; transporter.sendMail(mailOptions,(error, info)=>{if(error)=>{console.log(error);} else{console.log("email sent successfully", info.response);}})}
- in E-comm project we create verified-account endpoint to make sure that the email sent while registeration is already exist(valid) by sending otp_num to this email (send-otp endpoint) then the user resend it with his email in the body of verified-account endpoint.
- When we sign a token with process.env.JWT_SECRET, we must verify with the exact same string.

                              microservice
- microservice notation is to divide the main routers into separate micro-servers with different ports
  ,create gateway server that receive all requests then route each to its own main router server
  , this reduce the load on one server in big projects
  , we handle the accessability to these servers using cors() and manual-handled middlewares
  , so all requests are sent to the gatewayServer which in turn request for theses pathes in its corresponding microServer. 
- when me store variable in the session of one microServer(gateway) we must handle the setting of cors and fetch requests to use credentials (credentials:true in cors, credentials:"include" in fetch) 
  to keep it in cookie while the request is on the client, then use the same session for all requests come and go from this microServer
  .In addition, Using localhost vs 127.0.0.1 mismatch (cookie is domain-specific).

                              socket.io
- It's a tube connects different channels (frontend, backend).
- socket.io server deals with httpServer not with express, but at the same time express server more flexible for handling endpoints
  ,so we create an httpServer from express server at first (http.createServer(app)), then socket.io server from httpServer(new socketIo.Server(httpServer)).
- socket server cann't receive requests so it doesn't listen on any port, then the httpServer (which contain express server properties too) listen on port.
- to make io server run(emit io server), in html file we add :<script src="/socket.io/socket.io.js"></script> <script>const socket=io()</script>
  ,and in index.js file we declare the event: io.on("connection",(socket)=>{console.log("io server connected!); socket.on("disconnect",()=>{console.log("io server disconnected!);})}).
- when we want to render html file in the server we use(res.sendFile(html_file path)) as it isn't ejs file to render by (res.render(file-path))
- we refer to the socket.io server in client-side with socket, while in server-side with io.

                               general
- we use 'nodemon file_name' after we install nodemon library and create a script "dev" then run 'npm run dev', but if not we use 'npx nodemon file_name'.
- when we change in .env file we must restart the server manual as the server can't see this secret file.
- we put the command: require('dotenv').config({path:path.join(__dirname,'.env_file path')}) after requiring the dotenv and path library at the top of the entry file(index.js or server.js)
  ,but if the the .env file is in the same parent folder of the entry file(index) we use: {require('dotenv').config()} directly.
  ,and that's enough to use (process.env.{environment_variable}) in other files without the need to configure again.

                    codopia graduation project
- in (template-driven forms [formsModule]) we can use the method resetForm() with ngForm, but in reactive Forms we use only reset() with FormGroup 
  where it will reset to empty fields if no argument passed or to the original values passed to it as argument.
- zod library used for validation in back-end.
- jwt automatically adds the propery 'exp' representing the expiryDate of the token in seconds.
- BehaviorSubject<T>() used to listen any changes occured on the value of a variable, shared asObservable(). and the method .next(value) used to update the of the listened variable.
- we use discriminators with mongo schema to create different other models from that has common properties but also differ in some others.
- when we use .populate with mongodb model we must require the model refered-to first.
- we can pass params or query_params while navigating an angular component (router.navigate(['/...', param]) or router.navigate(['/...', {queryParams:{}}]))
  ,then in this component we access the params using: (route:activatedRoute.snapshot.paramMap.get(''))
  and the query_params with: (route.queryParams.subscribe(params=>{})).